package ivonhoe.java.bitmapanalyzer;import com.squareup.haha.perflib.ArrayInstance;import com.squareup.haha.perflib.ClassInstance;import com.squareup.haha.perflib.ClassObj;import com.squareup.haha.perflib.Field;import com.squareup.haha.perflib.HprofParser;import com.squareup.haha.perflib.Instance;import com.squareup.haha.perflib.Snapshot;import com.squareup.haha.perflib.Type;import com.squareup.haha.perflib.io.HprofBuffer;import com.squareup.haha.perflib.io.MemoryMappedFileBuffer;import java.awt.Point;import java.awt.image.BufferedImage;import java.awt.image.DataBuffer;import java.awt.image.DataBufferUShort;import java.awt.image.DirectColorModel;import java.awt.image.Raster;import java.awt.image.SampleModel;import java.awt.image.SinglePixelPackedSampleModel;import java.awt.image.WritableRaster;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;import java.nio.ByteBuffer;import java.nio.ByteOrder;import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map;import javax.imageio.ImageIO;import ivonhoe.java.util.Logger;/** * Created by Ivonhoe on 2017/3/14. */public class BitmapAnalyzer implements SnapshotAnalyzer {    public static void main(String[] args) {        if (args == null) {            Logger.d("请输入堆文件路径！");            return;        }        SnapshotAnalyzer analyzer = new BitmapAnalyzer(args);        String hprofPath = args[0];        File heapDumpFile = new File(hprofPath);        HprofBuffer hprofBuffer = null;        try {            hprofBuffer = new MemoryMappedFileBuffer(heapDumpFile);            HprofParser parser = new HprofParser(hprofBuffer);            Snapshot snapshot = parser.parse();            analyzer.onProcess(snapshot);        } catch (IOException e) {            e.printStackTrace();        }    }    private String mPathInput;    private String mPathOutput;    private Map<String, BitmapItem> mIndexMap = new HashMap<>();    private int mBitmapCount;    public BitmapAnalyzer(String[] args) {        mPathInput = args[0];        int index = mPathInput.lastIndexOf(File.separator);        mPathOutput = mPathInput.substring(0, index + 1);        if (args.length > 1) {            mPathOutput = mPathOutput + args[1];            if (!mPathOutput.endsWith(File.separator)) {                mPathOutput = mPathOutput + File.separator;            }            File file = new File(mPathOutput);            file.mkdirs();        }    }    @Override    public String filterKey() {        return "android.graphics.Bitmap";    }    @Override    public void onProcess(Snapshot snapshot) {        // The rest is up to you.        try {            ClassObj someClass = snapshot.findClass(filterKey());            mBitmapCount = someClass.getInstancesList().size();            for (Instance instance : someClass.getInstancesList()) {                if (instance instanceof ClassInstance) {                    ClassInstance classInstance = (ClassInstance) instance;                    int width = Toolkit.getIntField(classInstance, "mWidth");                    int height = Toolkit.getIntField(classInstance, "mHeight");                    Object[] byteArray = Toolkit.getArrayField(classInstance, "mBuffer");                    if (byteArray == null) {                        Logger.d("mBuffer is null!");                        continue;                    }                    int size = byteArray.length / (width * height);                    byte[] buffer = new byte[byteArray.length];                    for (int i = 0; i < buffer.length; i++) {                        buffer[i] = (Byte) byteArray[i];                    }                    BufferedImage image = null;                    if (size == 4) {                        int[] rgba = new int[width * height];                        for (int j = 0; j < width * height; j++) {                            rgba[j] = ((buffer[j * 4] << 16) | (buffer[j * 4 + 1] << 8) |                                    (buffer[j * 4 + 2]) | (buffer[j * 4 + 3] << 24));                        }                        image = Toolkit.create8888Image(rgba, width, height);                    } else if (size == 2) {                        short[] rgb = new short[width * height];                        for (int j = 0; j < width * height; j++) {                            byte[] b = new byte[]{buffer[2 * j], buffer[2 * j + 1]};                            rgb[j] = Toolkit.convertByteToShort(b);                        }                        image = Toolkit.create565Image(rgb, width, height);                    } else {                        Logger.d("不支持的RGB，size:" + size);                        continue;                    }                    if (image == null) {                        continue;                    }                    String outputName = getOutputName(width, height, Long.toHexString(instance.getUniqueId()));                    File output = new File(mPathOutput + outputName);                    Logger.d("保存图片到：" + output.getAbsolutePath());                    ImageIO.write(image, "png", output);                }            }        } catch (Exception e) {            e.printStackTrace();        }        //将分析结果写入文件        List<BitmapItem> bitmapItemList = getProcessedItemList();        sortByCount(bitmapItemList);        writeProcessLog(mPathOutput + "个数排序.txt", bitmapItemList);        sortBySize(bitmapItemList);        writeProcessLog(mPathOutput + "大小排序.txt", bitmapItemList);    }    private List<BitmapItem> getProcessedItemList() {        List<BitmapItem> bitmapItemList = new ArrayList<>();        Iterator iterator = mIndexMap.keySet().iterator();        while (iterator.hasNext()) {            String key = (String) iterator.next();            BitmapItem bitmapItem = mIndexMap.get(key);            int count = bitmapItem.getCount(); //mIndexMap.get(key);            float percent = ((float) count) / mBitmapCount;            bitmapItem.setPercent(percent);            bitmapItemList.add(bitmapItem);        }        return bitmapItemList;    }    private void sortByCount(List<BitmapItem> bitmapItemList) {        Comparator rowComparator = new Comparator<BitmapItem>() {            @Override            public int compare(BitmapItem lhs, BitmapItem rhs) {                if (lhs == null || rhs == null) {                    return 0;                }                return lhs.getPercent() > rhs.getPercent() ? -1 : 1;            }        };        Collections.sort(bitmapItemList, rowComparator);    }    private void sortBySize(List<BitmapItem> bitmapItemList) {        Comparator rowComparator = new Comparator<BitmapItem>() {            @Override            public int compare(BitmapItem lhs, BitmapItem rhs) {                if (lhs == null || rhs == null) {                    return 0;                }                return lhs.getWidth() * lhs.getHeight() > rhs.getWidth() * rhs.getHeight() ? -1 : 1;            }        };        Collections.sort(bitmapItemList, rowComparator);    }    private void writeProcessLog(String logPath, List<BitmapItem> bitmapItemList) {        StringBuilder stringBuilder = new StringBuilder();        for (BitmapItem item : bitmapItemList) {            stringBuilder.append(item).append("\r\n");        }        File file = new File(logPath);        File parent = file.getParentFile();        if (!parent.exists())            parent.mkdirs();        if (file.exists())            file.delete();        OutputStream out = null;        try {            out = new FileOutputStream(file);            out.write(stringBuilder.toString().getBytes());        } catch (IOException e) {            e.printStackTrace();        } finally {            if (out != null) {                try {                    out.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }    }    private String getOutputName(int width, int height, String id) {        String outputName = width + "*" + height;        BitmapItem item = mIndexMap.getOrDefault(outputName, new BitmapItem(width, height));        item.increase();        mIndexMap.put(outputName, item);        return outputName + "_0x" + id + ".png";    }    public static class Toolkit {        public static BufferedImage create8888Image(int[] pixels, int width, int height) {            BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);            image.setRGB(0, 0, width, height, pixels, 0, width);            return image;        }        public static BufferedImage create4444Image(short[] pixels, int width, int height) {            int size = width * height;            // 16 位色彩模型            DirectColorModel directColorModel = new DirectColorModel(16, 0xf00,                    0xf0, 0xf);            // 以 SinglePixelPackedSampleModel 构建像素包            SampleModel sample = new SinglePixelPackedSampleModel(                    DataBuffer.TYPE_USHORT, width, height, new int[]{0xf00, 0xf0, 0xf});            // 生成 DataBuffer            DataBuffer dataBuffer = new DataBufferUShort(pixels, size);            // 以 SampleModel 及 DataBuffer 生成 WritableRaster            WritableRaster raster = Raster.createWritableRaster(sample, dataBuffer,                    new Point(0, 0));            // 生成 BufferedImage            return new BufferedImage(directColorModel, raster, true, null);        }        static BufferedImage create565Image(short[] pixels, int width, int height) {            int size = width * height;            // 16 位色彩模型            DirectColorModel directColorModel = new DirectColorModel(16, 0xf800,                    0x7e0, 0x1f);            // 以 SinglePixelPackedSampleModel 构建像素包            SampleModel sample = new SinglePixelPackedSampleModel(                    DataBuffer.TYPE_USHORT, width, height, new int[]{0xf800, 0x7e0, 0x1f});            // 生成 DataBuffer            DataBuffer dataBuffer = new DataBufferUShort(pixels, size);            // 以 SampleModel 及 DataBuffer 生成 WritableRaster            WritableRaster raster = Raster.createWritableRaster(sample, dataBuffer,                    new Point(0, 0));            // 生成 BufferedImage            return new BufferedImage(directColorModel, raster, true, null);        }        public static short convertByteToShort(byte[] b) {            ByteBuffer bb = ByteBuffer.allocate(2);            bb.order(ByteOrder.LITTLE_ENDIAN);            bb.put(b[0]);            bb.put(b[1]);            return bb.getShort(0);        }        private static int getIntField(ClassInstance instance, String name) {            List<ClassInstance.FieldValue> fieldValues = instance.getValues();            for (ClassInstance.FieldValue fieldValue : fieldValues) {                Field field = fieldValue.getField();                Object value = fieldValue.getValue();                if (field.getName().equals(name) && field.getType() == Type.INT) {                    return (int) value;                }            }            return -1;        }        public static Object[] getArrayField(ClassInstance instance, String name) {            List<ClassInstance.FieldValue> fieldValues = instance.getValues();            for (ClassInstance.FieldValue fieldValue : fieldValues) {                Field field = fieldValue.getField();                Object value = fieldValue.getValue();                if (field.getName().equals(name) && value instanceof ArrayInstance) {                    ArrayInstance arrayInstance = (ArrayInstance) value;                    return arrayInstance.getValues();                }            }            return null;        }    }}